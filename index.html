<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>围棋打谱</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            min-height: 100vh;
        }
        #main-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            max-width: 1200px;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
        }
        #header {
            position: absolute;
            top: 20px;
            left: 20px;
        }
        #header h1 {
            margin: 0;
            font-size: 2em;
            color: #333;
        }
        #goban-container {
            margin-top: 60px;
            position: relative;
            background-color: #F1B458; /* 棋盘背景色 */
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
        }
        canvas {
            display: block;
            border: 2px solid #5E2E0C; /* 棋盘边框颜色 */
        }
        #controls-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #status {
            font-size: 1.2em;
            font-weight: bold;
            color: #555;
            margin-bottom: 10px;
        }
        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 5px;
            transition: background-color 0.2s;
            width: 120px;
        }
        button:hover {
            background-color: #eee;
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="header">
            <h1>围棋打谱</h1>
        </div>
        <div id="goban-container">
            <canvas id="goBoard"></canvas>
            <div id="controls-panel">
                <div id="status">当前执子：黑子</div>
                <div class="control-buttons">
                    <button id="confirmBtn">确认并保存</button>
                    <button id="resignBtn">投子认负</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('goBoard');
            const ctx = canvas.getContext('2d');
            const statusDiv = document.getElementById('status');
            const confirmBtn = document.getElementById('confirmBtn');
            const resignBtn = document.getElementById('resignBtn');

            const GRID_SIZE = 19;
            const CELL_SIZE = 30;
            const PADDING = 15;
            const BOARD_SIZE = (GRID_SIZE - 1) * CELL_SIZE + 2 * PADDING;
            canvas.width = canvas.height = BOARD_SIZE;

            let boardState = [];
            let currentPlayer = 1; // 1 for black, -1 for white
            let lastMove = null;

            function saveBoard() {
                localStorage.setItem('goBoardState', JSON.stringify(boardState));
                localStorage.setItem('goCurrentPlayer', currentPlayer);
            }

            function loadBoard() {
                const savedState = localStorage.getItem('goBoardState');
                const savedPlayer = localStorage.getItem('goCurrentPlayer');
                if (savedState) {
                    boardState = JSON.parse(savedState);
                    currentPlayer = parseInt(savedPlayer) || 1;
                } else {
                    boardState = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
                }
                updateStatus();
                drawBoard();
            }

            function updateStatus() {
                statusDiv.textContent = `当前执子：${currentPlayer === 1 ? '黑子' : '白子'}`;
            }

            function drawBoard() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#F1B458';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.strokeStyle = '#5E2E0C';
                ctx.lineWidth = 1;

                // Draw horizontal and vertical lines
                for (let i = 0; i < GRID_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
                    ctx.lineTo(PADDING + i * CELL_SIZE, BOARD_SIZE - PADDING);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
                    ctx.lineTo(BOARD_SIZE - PADDING, PADDING + i * CELL_SIZE);
                    ctx.stroke();
                }

                // Draw star points
                const starPoints = [[3, 3], [3, 9], [3, 15], [9, 3], [9, 9], [9, 15], [15, 3], [15, 9], [15, 15]];
                ctx.fillStyle = '#5E2E0C';
                starPoints.forEach(([x, y]) => {
                    ctx.beginPath();
                    ctx.arc(PADDING + x * CELL_SIZE, PADDING + y * CELL_SIZE, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });

                // Draw all stones
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const stone = boardState[y][x];
                        if (stone !== 0) {
                            ctx.beginPath();
                            ctx.arc(PADDING + x * CELL_SIZE, PADDING + y * CELL_SIZE, CELL_SIZE / 2 - 2, 0, 2 * Math.PI);
                            ctx.fillStyle = stone === 1 ? '#222' : '#eee';
                            ctx.fill();
                            ctx.strokeStyle = stone === 1 ? '#eee' : '#222';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                }
            }

            function getLiberties(x, y, color, visited) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE || visited[y][x]) {
                    return 0;
                }
                visited[y][x] = true;

                if (boardState[y][x] === 0) {
                    return 1;
                }
                if (boardState[y][x] !== color) {
                    return 0;
                }

                return getLiberties(x + 1, y, color, visited) +
                       getLiberties(x - 1, y, color, visited) +
                       getLiberties(x, y + 1, color, visited) +
                       getLiberties(x, y - 1, color, visited);
            }

            function getGroup(x, y, color, group) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE || boardState[y][x] !== color) {
                    return;
                }
                if (group.some(s => s[0] === x && s[1] === y)) {
                    return;
                }
                group.push([x, y]);
                getGroup(x + 1, y, color, group);
                getGroup(x - 1, y, color, group);
                getGroup(x, y + 1, color, group);
                getGroup(x, y - 1, color, group);
            }

            function checkCaptures(x, y, player) {
                let capturedStones = [];
                const opponent = -player;
                const neighbors = [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]];

                neighbors.forEach(([nx, ny]) => {
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && boardState[ny][nx] === opponent) {
                        const group = [];
                        getGroup(nx, ny, opponent, group);
                        const liberties = group.reduce((sum, [gx, gy]) => {
                            const visited = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
                            return sum + getLiberties(gx, gy, opponent, visited);
                        }, 0);
                        if (liberties === 0) {
                            capturedStones = capturedStones.concat(group);
                        }
                    }
                });

                return capturedStones;
            }

            function handleBoardClick(event) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const x = Math.round((mouseX - PADDING) / CELL_SIZE);
                const y = Math.round((mouseY - PADDING) / CELL_SIZE);

                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && boardState[y][x] === 0) {
                    lastMove = [x, y];
                    const tempBoard = JSON.parse(JSON.stringify(boardState));
                    tempBoard[y][x] = currentPlayer;

                    // Check for suicide
                    const group = [];
                    getGroup(x, y, currentPlayer, group);
                    const liberties = group.reduce((sum, [gx, gy]) => {
                        const visited = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
                        return sum + getLiberties(gx, gy, currentPlayer, visited);
                    }, 0);

                    const captured = checkCaptures(x, y, currentPlayer);

                    if (liberties === 0 && captured.length === 0) {
                        alert("规则错误: 自杀落子！");
                        lastMove = null;
                        return;
                    }

                    boardState[y][x] = currentPlayer;

                    // Capture opponent stones
                    if (captured.length > 0) {
                        captured.forEach(([cx, cy]) => {
                            boardState[cy][cx] = 0;
                        });
                    }

                    currentPlayer *= -1;
                    updateStatus();
                    drawBoard();
                    saveBoard();
                }
            }

            function resetBoard() {
                boardState = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
                currentPlayer = 1;
                lastMove = null;
                updateStatus();
                drawBoard();
                saveBoard();
            }

            canvas.addEventListener('click', handleBoardClick);
            confirmBtn.addEventListener('click', saveBoard);
            resignBtn.addEventListener('click', resetBoard);

            loadBoard();
        });
    </script>
</body>
</html>
